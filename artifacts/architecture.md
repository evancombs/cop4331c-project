# Program Organization
## Context Diagram
The system context diagram provides a starting point, showing how the unity environment will interact with the world around it.
![alt tag](https://i.postimg.cc/DwtTHKjK/ES-Context-Diagram.png "Context Diagram")

## Container Diagram
The container diagram zooms into the scope of what unity will encounter, showing some of the more high-level building blocks of the project.

![alt tag](https://i.postimg.cc/QxTSSGT7/ES-Container-Diagram.png "Container Diagram")

## Components Diagram
The components diagram zooms into the individual containers and defines the components(conditions and functionalities) that each possesses. 

![alt tag](https://i.postimg.cc/RFv4WL8Q/ES-Component-Diagram-2.png "Component Diagram")

# Code Design
The UML class diagram is used to have a zoomed in look into individual componenets and provides a look at how these componenets are implemented.

![alt tag](https://i.imgur.com/p6lJmlW.png)

# Data Design

# Business Rules

# User Interface Design

# Resource Management

# Security

# Performance

# Interoperability

# Internalization/ Localization

# Input/ Output

# Error Processing
  We will follow a passive corrective error processing approach, when possible. Given that the core of our system depends on interactions between many objects, a relatively low impact option is always to remove a problem-causing object; with sufficiently large numbers, the system is relatively unnafected.
# Fault Tolerance

# Architectural Feasibility

# Overengineering

# Build-vs-Buy Decisions

# Reuse

# Change Strategy
  When it becomes apparent that change may be necesary, we will meet early and often to discuss if the change is needed. Should we determine that yes, it is, we will first update our project architecture, stories, and requirements, then attempt to implement the change as early as possible.









