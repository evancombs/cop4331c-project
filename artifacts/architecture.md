# Program Organization

# - Context Diagram
The system context diagram provides a starting point, showing how the unity environment will interact with the world around it.

![alt tag](https://i.postimg.cc/DwtTHKjK/ES-Context-Diagram.png "Context Diagram")

# - Container Diagram
The container diagram zooms into the scope of what unity will encounter, showing some of the more high-level building blocks of the project.

![alt tag](https://i.postimg.cc/QxTSSGT7/ES-Container-Diagram.png "Container Diagram")

# - Components Diagram
The components diagram zooms into the indovidual containers and defines the components(conditions and functionalities) that each possesses. 

![alt tag](https://i.postimg.cc/g2p5ZkTj/ES-Component-Diagram.png "Component Diagram")

# Code Design
The UML class diagram is used to have a zoomed in look into individual componenets and provides a look at how these componenets are implemented.

![alt tag](https://i.postimg.cc/rp421Y9F/COP4331-Script-Structure.png "UML Diagram")

See Code Complete, Chapter 3 and https://c4model.com/

# Data Design

If you are using a database, you should have a basic Entity Relationship Diagram (ERD) in this section. This diagram should describe the tables in your database and their relationship to one another (especially primary/foreign keys), including the columns within each table. 

See Code Complete, Chapter 3

# Business Rules

You should list the assumptions, rules, and guidelines from external sources that are impacting your program design. 

See Code Complete, Chapter 3

# User Interface Design

You should have one or more user interface screens in this section. Each screen should be accompanied by an explaination of the screens purpose and how the user will interact with it. You should relate each screen to one another as the user transitions through the states of your application. You should also have a table that relates each window or component to the support using stories. 

See Code Complete, Chapter 3

# Resource Management

See Code Complete, Chapter 3

# Security

See Code Complete, Chapter 3

# Performance

See Code Complete, Chapter 3

# Scalability

See Code Complete, Chapter 3

# Interoperability

See Code Complete, Chapter 3

# Internationalization/Localization

See Code Complete, Chapter 3

# Input/Output

See Code Complete, Chapter 3

# Error Processing

See Code Complete, Chapter 3

# Fault Tolerance

See Code Complete, Chapter 3

# Architectural Feasibility

See Code Complete, Chapter 3

# Overengineering

See Code Complete, Chapter 3

# Build-vs-Buy Decisions

This section should list the third party libraries your system is using and describe what those libraries are being used for.

See Code Complete, Chapter 3

# Reuse

See Code Complete, Chapter 3

# Change Strategy

See Code Complete, Chapter 3
